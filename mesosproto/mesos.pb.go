// Code generated by protoc-gen-gogo.
// source: mesos.proto
// DO NOT EDIT!

package mesosproto

import proto "code.google.com/p/gogoprotobuf/proto"
import json "encoding/json"
import math "math"

// Reference proto, json, and math imports to suppress error if they are not otherwise used.
var _ = proto.Marshal
var _ = &json.SyntaxError{}
var _ = math.Inf

// *
// Status is used to indicate the state of the scheduler and executor
// driver after function calls.
type Status int32

const (
	Status_DRIVER_NOT_STARTED Status = 1
	Status_DRIVER_RUNNING     Status = 2
	Status_DRIVER_ABORTED     Status = 3
	Status_DRIVER_STOPPED     Status = 4
)

var Status_name = map[int32]string{
	1: "DRIVER_NOT_STARTED",
	2: "DRIVER_RUNNING",
	3: "DRIVER_ABORTED",
	4: "DRIVER_STOPPED",
}
var Status_value = map[string]int32{
	"DRIVER_NOT_STARTED": 1,
	"DRIVER_RUNNING":     2,
	"DRIVER_ABORTED":     3,
	"DRIVER_STOPPED":     4,
}

func (x Status) Enum() *Status {
	p := new(Status)
	*p = x
	return p
}
func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (x *Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Status_value, data, "Status")
	if err != nil {
		return err
	}
	*x = Status(value)
	return nil
}

// *
// Describes possible task states. IMPORTANT: Mesos assumes tasks that
// enter terminal states (see below) imply the task is no longer
// running and thus clean up any thing associated with the task
// (ultimately offering any resources being consumed by that task to
// another task).
type TaskState int32

const (
	TaskState_TASK_STAGING  TaskState = 6
	TaskState_TASK_STARTING TaskState = 0
	TaskState_TASK_RUNNING  TaskState = 1
	TaskState_TASK_FINISHED TaskState = 2
	TaskState_TASK_FAILED   TaskState = 3
	TaskState_TASK_KILLED   TaskState = 4
	TaskState_TASK_LOST     TaskState = 5
)

var TaskState_name = map[int32]string{
	6: "TASK_STAGING",
	0: "TASK_STARTING",
	1: "TASK_RUNNING",
	2: "TASK_FINISHED",
	3: "TASK_FAILED",
	4: "TASK_KILLED",
	5: "TASK_LOST",
}
var TaskState_value = map[string]int32{
	"TASK_STAGING":  6,
	"TASK_STARTING": 0,
	"TASK_RUNNING":  1,
	"TASK_FINISHED": 2,
	"TASK_FAILED":   3,
	"TASK_KILLED":   4,
	"TASK_LOST":     5,
}

func (x TaskState) Enum() *TaskState {
	p := new(TaskState)
	*p = x
	return p
}
func (x TaskState) String() string {
	return proto.EnumName(TaskState_name, int32(x))
}
func (x *TaskState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TaskState_value, data, "TaskState")
	if err != nil {
		return err
	}
	*x = TaskState(value)
	return nil
}

type Value_Type int32

const (
	Value_SCALAR Value_Type = 0
	Value_RANGES Value_Type = 1
	Value_SET    Value_Type = 2
	Value_TEXT   Value_Type = 3
)

var Value_Type_name = map[int32]string{
	0: "SCALAR",
	1: "RANGES",
	2: "SET",
	3: "TEXT",
}
var Value_Type_value = map[string]int32{
	"SCALAR": 0,
	"RANGES": 1,
	"SET":    2,
	"TEXT":   3,
}

func (x Value_Type) Enum() *Value_Type {
	p := new(Value_Type)
	*p = x
	return p
}
func (x Value_Type) String() string {
	return proto.EnumName(Value_Type_name, int32(x))
}
func (x *Value_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Value_Type_value, data, "Value_Type")
	if err != nil {
		return err
	}
	*x = Value_Type(value)
	return nil
}

type ACL_Entity_Type int32

const (
	ACL_Entity_SOME ACL_Entity_Type = 0
	ACL_Entity_ANY  ACL_Entity_Type = 1
	ACL_Entity_NONE ACL_Entity_Type = 2
)

var ACL_Entity_Type_name = map[int32]string{
	0: "SOME",
	1: "ANY",
	2: "NONE",
}
var ACL_Entity_Type_value = map[string]int32{
	"SOME": 0,
	"ANY":  1,
	"NONE": 2,
}

func (x ACL_Entity_Type) Enum() *ACL_Entity_Type {
	p := new(ACL_Entity_Type)
	*p = x
	return p
}
func (x ACL_Entity_Type) String() string {
	return proto.EnumName(ACL_Entity_Type_name, int32(x))
}
func (x *ACL_Entity_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ACL_Entity_Type_value, data, "ACL_Entity_Type")
	if err != nil {
		return err
	}
	*x = ACL_Entity_Type(value)
	return nil
}

type Volume_Mode int32

const (
	Volume_RW Volume_Mode = 1
	Volume_RO Volume_Mode = 2
)

var Volume_Mode_name = map[int32]string{
	1: "RW",
	2: "RO",
}
var Volume_Mode_value = map[string]int32{
	"RW": 1,
	"RO": 2,
}

func (x Volume_Mode) Enum() *Volume_Mode {
	p := new(Volume_Mode)
	*p = x
	return p
}
func (x Volume_Mode) String() string {
	return proto.EnumName(Volume_Mode_name, int32(x))
}
func (x *Volume_Mode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Volume_Mode_value, data, "Volume_Mode")
	if err != nil {
		return err
	}
	*x = Volume_Mode(value)
	return nil
}

// All container implementation types.
type ContainerInfo_Type int32

const (
	ContainerInfo_DOCKER ContainerInfo_Type = 1
)

var ContainerInfo_Type_name = map[int32]string{
	1: "DOCKER",
}
var ContainerInfo_Type_value = map[string]int32{
	"DOCKER": 1,
}

func (x ContainerInfo_Type) Enum() *ContainerInfo_Type {
	p := new(ContainerInfo_Type)
	*p = x
	return p
}
func (x ContainerInfo_Type) String() string {
	return proto.EnumName(ContainerInfo_Type_name, int32(x))
}
func (x *ContainerInfo_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContainerInfo_Type_value, data, "ContainerInfo_Type")
	if err != nil {
		return err
	}
	*x = ContainerInfo_Type(value)
	return nil
}

// Network options.
type ContainerInfo_DockerInfo_Network int32

const (
	ContainerInfo_DockerInfo_HOST   ContainerInfo_DockerInfo_Network = 1
	ContainerInfo_DockerInfo_BRIDGE ContainerInfo_DockerInfo_Network = 2
)

var ContainerInfo_DockerInfo_Network_name = map[int32]string{
	1: "HOST",
	2: "BRIDGE",
}
var ContainerInfo_DockerInfo_Network_value = map[string]int32{
	"HOST":   1,
	"BRIDGE": 2,
}

func (x ContainerInfo_DockerInfo_Network) Enum() *ContainerInfo_DockerInfo_Network {
	p := new(ContainerInfo_DockerInfo_Network)
	*p = x
	return p
}
func (x ContainerInfo_DockerInfo_Network) String() string {
	return proto.EnumName(ContainerInfo_DockerInfo_Network_name, int32(x))
}
func (x *ContainerInfo_DockerInfo_Network) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContainerInfo_DockerInfo_Network_value, data, "ContainerInfo_DockerInfo_Network")
	if err != nil {
		return err
	}
	*x = ContainerInfo_DockerInfo_Network(value)
	return nil
}

// *
// A unique ID assigned to a framework. A framework can reuse this ID
// in order to do failover (see MesosSchedulerDriver).
type FrameworkID struct {
	Value            *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FrameworkID) Reset()         { *m = FrameworkID{} }
func (m *FrameworkID) String() string { return proto.CompactTextString(m) }
func (*FrameworkID) ProtoMessage()    {}

func (m *FrameworkID) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// A unique ID assigned to an offer.
type OfferID struct {
	Value            *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *OfferID) Reset()         { *m = OfferID{} }
func (m *OfferID) String() string { return proto.CompactTextString(m) }
func (*OfferID) ProtoMessage()    {}

func (m *OfferID) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// A unique ID assigned to a slave. Currently, a slave gets a new ID
// whenever it (re)registers with Mesos. Framework writers shouldn't
// assume any binding between a slave ID and and a hostname.
type SlaveID struct {
	Value            *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SlaveID) Reset()         { *m = SlaveID{} }
func (m *SlaveID) String() string { return proto.CompactTextString(m) }
func (*SlaveID) ProtoMessage()    {}

func (m *SlaveID) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// A framework generated ID to distinguish a task. The ID must remain
// unique while the task is active. However, a framework can reuse an
// ID _only_ if a previous task with the same ID has reached a
// terminal state (e.g., TASK_FINISHED, TASK_LOST, TASK_KILLED, etc.).
type TaskID struct {
	Value            *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TaskID) Reset()         { *m = TaskID{} }
func (m *TaskID) String() string { return proto.CompactTextString(m) }
func (*TaskID) ProtoMessage()    {}

func (m *TaskID) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// A framework generated ID to distinguish an executor. Only one
// executor with the same ID can be active on the same slave at a
// time.
type ExecutorID struct {
	Value            *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ExecutorID) Reset()         { *m = ExecutorID{} }
func (m *ExecutorID) String() string { return proto.CompactTextString(m) }
func (*ExecutorID) ProtoMessage()    {}

func (m *ExecutorID) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// A slave generated ID to distinguish a container. The ID must be unique
// between any active or completed containers on the slave. In particular,
// containers for different runs of the same (framework, executor) pair must be
// unique.
type ContainerID struct {
	Value            *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ContainerID) Reset()         { *m = ContainerID{} }
func (m *ContainerID) String() string { return proto.CompactTextString(m) }
func (*ContainerID) ProtoMessage()    {}

func (m *ContainerID) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// Describes a framework. The user field is used to determine the
// Unix user that an executor/task should be launched as. If the user
// field is set to an empty string Mesos will automagically set it
// to the current user. Note that the ID is only available after a
// framework has registered, however, it is included here in order to
// facilitate scheduler failover (i.e., if it is set then the
// MesosSchedulerDriver expects the scheduler is performing failover).
// The amount of time that the master will wait for the scheduler to
// failover before removing the framework is specified by
// failover_timeout. If checkpoint is set, framework pid, executor
// pids and status updates are checkpointed to disk by the slaves.
// Checkpointing allows a restarted slave to reconnect with old
// executors and recover status updates, at the cost of disk I/O.
// The role field is used to group frameworks for allocation
// decisions, depending on the allocation policy being used.
// If the hostname field is set to an empty string Mesos will
// automagically set it to the current hostname.
// The principal field should match the credential the framework uses
// in authentication. This field is used for framework API rate
// exporting and limiting and should be set even if authentication is
// not enabled if these features are desired.
// The webui_url field allows a framework to advertise its web UI, so
// that the Mesos web UI can link to it. It is expected to be a full
// URL, for example http://my-scheduler.example.com:8080/.
type FrameworkInfo struct {
	User             *string      `protobuf:"bytes,1,req,name=user" json:"user,omitempty"`
	Name             *string      `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
	Id               *FrameworkID `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
	FailoverTimeout  *float64     `protobuf:"fixed64,4,opt,name=failover_timeout,def=0" json:"failover_timeout,omitempty"`
	Checkpoint       *bool        `protobuf:"varint,5,opt,name=checkpoint,def=0" json:"checkpoint,omitempty"`
	Role             *string      `protobuf:"bytes,6,opt,name=role,def=*" json:"role,omitempty"`
	Hostname         *string      `protobuf:"bytes,7,opt,name=hostname" json:"hostname,omitempty"`
	Principal        *string      `protobuf:"bytes,8,opt,name=principal" json:"principal,omitempty"`
	WebuiUrl         *string      `protobuf:"bytes,9,opt,name=webui_url" json:"webui_url,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *FrameworkInfo) Reset()         { *m = FrameworkInfo{} }
func (m *FrameworkInfo) String() string { return proto.CompactTextString(m) }
func (*FrameworkInfo) ProtoMessage()    {}

const Default_FrameworkInfo_FailoverTimeout float64 = 0
const Default_FrameworkInfo_Checkpoint bool = false
const Default_FrameworkInfo_Role string = "*"

func (m *FrameworkInfo) GetUser() string {
	if m != nil && m.User != nil {
		return *m.User
	}
	return ""
}

func (m *FrameworkInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *FrameworkInfo) GetId() *FrameworkID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *FrameworkInfo) GetFailoverTimeout() float64 {
	if m != nil && m.FailoverTimeout != nil {
		return *m.FailoverTimeout
	}
	return Default_FrameworkInfo_FailoverTimeout
}

func (m *FrameworkInfo) GetCheckpoint() bool {
	if m != nil && m.Checkpoint != nil {
		return *m.Checkpoint
	}
	return Default_FrameworkInfo_Checkpoint
}

func (m *FrameworkInfo) GetRole() string {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return Default_FrameworkInfo_Role
}

func (m *FrameworkInfo) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *FrameworkInfo) GetPrincipal() string {
	if m != nil && m.Principal != nil {
		return *m.Principal
	}
	return ""
}

func (m *FrameworkInfo) GetWebuiUrl() string {
	if m != nil && m.WebuiUrl != nil {
		return *m.WebuiUrl
	}
	return ""
}

// *
// Describes a health check for a task or executor (or any arbitrary
// process/command). A "strategy" is picked by specifying one of the
// optional fields, currently only 'http' and 'command' are
// supported. Specifying more than one strategy is an error.
type HealthCheck struct {
	Http *HealthCheck_HTTP `protobuf:"bytes,1,opt,name=http" json:"http,omitempty"`
	// Amount of time to wait until starting the health checks.
	DelaySeconds *float64 `protobuf:"fixed64,2,opt,name=delay_seconds,def=15" json:"delay_seconds,omitempty"`
	// Interval between health checks.
	IntervalSeconds *float64 `protobuf:"fixed64,3,opt,name=interval_seconds,def=10" json:"interval_seconds,omitempty"`
	// Amount of time to wait for the health check to complete.
	TimeoutSeconds *float64 `protobuf:"fixed64,4,opt,name=timeout_seconds,def=20" json:"timeout_seconds,omitempty"`
	// Number of consecutive failures until considered unhealthy.
	ConsecutiveFailures *uint32 `protobuf:"varint,5,opt,name=consecutive_failures,def=3" json:"consecutive_failures,omitempty"`
	// Amount of time to allow failed health checks since launch.
	GracePeriodSeconds *float64 `protobuf:"fixed64,6,opt,name=grace_period_seconds,def=10" json:"grace_period_seconds,omitempty"`
	// Command health check.
	Command          *CommandInfo `protobuf:"bytes,7,opt,name=command" json:"command,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *HealthCheck) Reset()         { *m = HealthCheck{} }
func (m *HealthCheck) String() string { return proto.CompactTextString(m) }
func (*HealthCheck) ProtoMessage()    {}

const Default_HealthCheck_DelaySeconds float64 = 15
const Default_HealthCheck_IntervalSeconds float64 = 10
const Default_HealthCheck_TimeoutSeconds float64 = 20
const Default_HealthCheck_ConsecutiveFailures uint32 = 3
const Default_HealthCheck_GracePeriodSeconds float64 = 10

func (m *HealthCheck) GetHttp() *HealthCheck_HTTP {
	if m != nil {
		return m.Http
	}
	return nil
}

func (m *HealthCheck) GetDelaySeconds() float64 {
	if m != nil && m.DelaySeconds != nil {
		return *m.DelaySeconds
	}
	return Default_HealthCheck_DelaySeconds
}

func (m *HealthCheck) GetIntervalSeconds() float64 {
	if m != nil && m.IntervalSeconds != nil {
		return *m.IntervalSeconds
	}
	return Default_HealthCheck_IntervalSeconds
}

func (m *HealthCheck) GetTimeoutSeconds() float64 {
	if m != nil && m.TimeoutSeconds != nil {
		return *m.TimeoutSeconds
	}
	return Default_HealthCheck_TimeoutSeconds
}

func (m *HealthCheck) GetConsecutiveFailures() uint32 {
	if m != nil && m.ConsecutiveFailures != nil {
		return *m.ConsecutiveFailures
	}
	return Default_HealthCheck_ConsecutiveFailures
}

func (m *HealthCheck) GetGracePeriodSeconds() float64 {
	if m != nil && m.GracePeriodSeconds != nil {
		return *m.GracePeriodSeconds
	}
	return Default_HealthCheck_GracePeriodSeconds
}

func (m *HealthCheck) GetCommand() *CommandInfo {
	if m != nil {
		return m.Command
	}
	return nil
}

// Describes an HTTP health check.
type HealthCheck_HTTP struct {
	// Port to send the HTTP request.
	Port *uint32 `protobuf:"varint,1,req,name=port" json:"port,omitempty"`
	// HTTP request path.
	Path *string `protobuf:"bytes,2,opt,name=path,def=/" json:"path,omitempty"`
	// Expected response statuses. Not specifying any statuses implies
	// that any returned status is acceptable.
	Statuses         []uint32 `protobuf:"varint,4,rep,name=statuses" json:"statuses,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *HealthCheck_HTTP) Reset()         { *m = HealthCheck_HTTP{} }
func (m *HealthCheck_HTTP) String() string { return proto.CompactTextString(m) }
func (*HealthCheck_HTTP) ProtoMessage()    {}

const Default_HealthCheck_HTTP_Path string = "/"

func (m *HealthCheck_HTTP) GetPort() uint32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *HealthCheck_HTTP) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return Default_HealthCheck_HTTP_Path
}

func (m *HealthCheck_HTTP) GetStatuses() []uint32 {
	if m != nil {
		return m.Statuses
	}
	return nil
}

// *
// Describes a command, executed via: '/bin/sh -c value'. Any URIs specified
// are fetched before executing the command.  If the executable field for an
// uri is set, executable file permission is set on the downloaded file.
// Otherwise, if the downloaded file has a recognized archive extension
// (currently [compressed] tar and zip) it is extracted into the executor's
// working directory. This extraction can be disabled by setting `extract` to
// false. In addition, any environment variables are set before executing
// the command (so they can be used to "parameterize" your command).
type CommandInfo struct {
	// NOTE: MesosContainerizer does currently not support this
	// attribute and tasks supplying a 'container' will fail.
	Container   *CommandInfo_ContainerInfo `protobuf:"bytes,4,opt,name=container" json:"container,omitempty"`
	Uris        []*CommandInfo_URI         `protobuf:"bytes,1,rep,name=uris" json:"uris,omitempty"`
	Environment *Environment               `protobuf:"bytes,2,opt,name=environment" json:"environment,omitempty"`
	// There are two ways to specify the command:
	// 1) If 'shell == true', the command will be launched via shell
	// 		(i.e., /bin/sh -c 'value'). The 'value' specified will be
	// 		treated as the shell command. The 'arguments' will be ignored.
	// 2) If 'shell == false', the command will be launched by passing
	// 		arguments to an executable. The 'value' specified will be
	// 		treated as the filename of the executable. The 'arguments'
	// 		will be treated as the arguments to the executable. This is
	// 		similar to how POSIX exec families launch processes (i.e.,
	// 		execlp(value, arguments(0), arguments(1), ...)).
	// NOTE: The field 'value' is changed from 'required' to 'optional'
	// in 0.20.0. It will only cause issues if a new framework is
	// connecting to an old master.
	Shell     *bool    `protobuf:"varint,6,opt,name=shell,def=1" json:"shell,omitempty"`
	Value     *string  `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	Arguments []string `protobuf:"bytes,7,rep,name=arguments" json:"arguments,omitempty"`
	// Enables executor and tasks to run as a specific user. If the user
	// field is present both in FrameworkInfo and here, the CommandInfo
	// user value takes precedence.
	User             *string `protobuf:"bytes,5,opt,name=user" json:"user,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CommandInfo) Reset()         { *m = CommandInfo{} }
func (m *CommandInfo) String() string { return proto.CompactTextString(m) }
func (*CommandInfo) ProtoMessage()    {}

const Default_CommandInfo_Shell bool = true

func (m *CommandInfo) GetContainer() *CommandInfo_ContainerInfo {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *CommandInfo) GetUris() []*CommandInfo_URI {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *CommandInfo) GetEnvironment() *Environment {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *CommandInfo) GetShell() bool {
	if m != nil && m.Shell != nil {
		return *m.Shell
	}
	return Default_CommandInfo_Shell
}

func (m *CommandInfo) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *CommandInfo) GetArguments() []string {
	if m != nil {
		return m.Arguments
	}
	return nil
}

func (m *CommandInfo) GetUser() string {
	if m != nil && m.User != nil {
		return *m.User
	}
	return ""
}

type CommandInfo_URI struct {
	Value            *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	Executable       *bool   `protobuf:"varint,2,opt,name=executable" json:"executable,omitempty"`
	Extract          *bool   `protobuf:"varint,3,opt,name=extract,def=1" json:"extract,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CommandInfo_URI) Reset()         { *m = CommandInfo_URI{} }
func (m *CommandInfo_URI) String() string { return proto.CompactTextString(m) }
func (*CommandInfo_URI) ProtoMessage()    {}

const Default_CommandInfo_URI_Extract bool = true

func (m *CommandInfo_URI) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *CommandInfo_URI) GetExecutable() bool {
	if m != nil && m.Executable != nil {
		return *m.Executable
	}
	return false
}

func (m *CommandInfo_URI) GetExtract() bool {
	if m != nil && m.Extract != nil {
		return *m.Extract
	}
	return Default_CommandInfo_URI_Extract
}

// Describes a container.
// Not all containerizers currently implement ContainerInfo, so it
// is possible that a launched task will fail due to supplying this
// attribute.
// NOTE: The containerizer API is currently in an early beta or
// even alpha state. Some details, like the exact semantics of an
// "image" or "options" are not yet hardened.
// TODO(tillt): Describe the exact scheme and semantics of "image"
// and "options".
type CommandInfo_ContainerInfo struct {
	// URI describing the container image name.
	Image *string `protobuf:"bytes,1,req,name=image" json:"image,omitempty"`
	// Describes additional options passed to the containerizer.
	Options          []string `protobuf:"bytes,2,rep,name=options" json:"options,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CommandInfo_ContainerInfo) Reset()         { *m = CommandInfo_ContainerInfo{} }
func (m *CommandInfo_ContainerInfo) String() string { return proto.CompactTextString(m) }
func (*CommandInfo_ContainerInfo) ProtoMessage()    {}

func (m *CommandInfo_ContainerInfo) GetImage() string {
	if m != nil && m.Image != nil {
		return *m.Image
	}
	return ""
}

func (m *CommandInfo_ContainerInfo) GetOptions() []string {
	if m != nil {
		return m.Options
	}
	return nil
}

// *
// Describes information about an executor. The 'data' field can be
// used to pass arbitrary bytes to an executor.
type ExecutorInfo struct {
	ExecutorId  *ExecutorID  `protobuf:"bytes,1,req,name=executor_id" json:"executor_id,omitempty"`
	FrameworkId *FrameworkID `protobuf:"bytes,8,opt,name=framework_id" json:"framework_id,omitempty"`
	Command     *CommandInfo `protobuf:"bytes,7,req,name=command" json:"command,omitempty"`
	// Executor provided with a container will launch the container
	// with the executor's CommandInfo and we expect the container to
	// act as a Mesos executor.
	Container *ContainerInfo `protobuf:"bytes,11,opt,name=container" json:"container,omitempty"`
	Resources []*Resource    `protobuf:"bytes,5,rep,name=resources" json:"resources,omitempty"`
	Name      *string        `protobuf:"bytes,9,opt,name=name" json:"name,omitempty"`
	// Source is an identifier style string used by frameworks to track
	// the source of an executor. This is useful when it's possible for
	// different executor ids to be related semantically.
	// NOTE: Source is exposed alongside the resource usage of the
	// executor via JSON on the slave. This allows users to import
	// usage information into a time series database for monitoring.
	Source           *string `protobuf:"bytes,10,opt,name=source" json:"source,omitempty"`
	Data             []byte  `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ExecutorInfo) Reset()         { *m = ExecutorInfo{} }
func (m *ExecutorInfo) String() string { return proto.CompactTextString(m) }
func (*ExecutorInfo) ProtoMessage()    {}

func (m *ExecutorInfo) GetExecutorId() *ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

func (m *ExecutorInfo) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *ExecutorInfo) GetCommand() *CommandInfo {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ExecutorInfo) GetContainer() *ContainerInfo {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *ExecutorInfo) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *ExecutorInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ExecutorInfo) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *ExecutorInfo) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// *
// Describes a master. This will probably have more fields in the
// future which might be used, for example, to link a framework webui
// to a master webui.
type MasterInfo struct {
	Id               *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Ip               *uint32 `protobuf:"varint,2,req,name=ip" json:"ip,omitempty"`
	Port             *uint32 `protobuf:"varint,3,req,name=port,def=5050" json:"port,omitempty"`
	Pid              *string `protobuf:"bytes,4,opt,name=pid" json:"pid,omitempty"`
	Hostname         *string `protobuf:"bytes,5,opt,name=hostname" json:"hostname,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *MasterInfo) Reset()         { *m = MasterInfo{} }
func (m *MasterInfo) String() string { return proto.CompactTextString(m) }
func (*MasterInfo) ProtoMessage()    {}

const Default_MasterInfo_Port uint32 = 5050

func (m *MasterInfo) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *MasterInfo) GetIp() uint32 {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return 0
}

func (m *MasterInfo) GetPort() uint32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return Default_MasterInfo_Port
}

func (m *MasterInfo) GetPid() string {
	if m != nil && m.Pid != nil {
		return *m.Pid
	}
	return ""
}

func (m *MasterInfo) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

// *
// Describes a slave. Note that the 'id' field is only available after
// a slave is registered with the master, and is made available here
// to facilitate re-registration.  If checkpoint is set, the slave is
// checkpointing its own information and potentially frameworks'
// information (if a framework has checkpointing enabled).
type SlaveInfo struct {
	Hostname         *string      `protobuf:"bytes,1,req,name=hostname" json:"hostname,omitempty"`
	Port             *int32       `protobuf:"varint,8,opt,name=port,def=5051" json:"port,omitempty"`
	Resources        []*Resource  `protobuf:"bytes,3,rep,name=resources" json:"resources,omitempty"`
	Attributes       []*Attribute `protobuf:"bytes,5,rep,name=attributes" json:"attributes,omitempty"`
	Id               *SlaveID     `protobuf:"bytes,6,opt,name=id" json:"id,omitempty"`
	Checkpoint       *bool        `protobuf:"varint,7,opt,name=checkpoint,def=0" json:"checkpoint,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *SlaveInfo) Reset()         { *m = SlaveInfo{} }
func (m *SlaveInfo) String() string { return proto.CompactTextString(m) }
func (*SlaveInfo) ProtoMessage()    {}

const Default_SlaveInfo_Port int32 = 5051
const Default_SlaveInfo_Checkpoint bool = false

func (m *SlaveInfo) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *SlaveInfo) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return Default_SlaveInfo_Port
}

func (m *SlaveInfo) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *SlaveInfo) GetAttributes() []*Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *SlaveInfo) GetId() *SlaveID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SlaveInfo) GetCheckpoint() bool {
	if m != nil && m.Checkpoint != nil {
		return *m.Checkpoint
	}
	return Default_SlaveInfo_Checkpoint
}

// *
// Describes an Attribute or Resource "value". A value is described
// using the standard protocol buffer "union" trick.
type Value struct {
	Type             *Value_Type   `protobuf:"varint,1,req,name=type,enum=mesosproto.Value_Type" json:"type,omitempty"`
	Scalar           *Value_Scalar `protobuf:"bytes,2,opt,name=scalar" json:"scalar,omitempty"`
	Ranges           *Value_Ranges `protobuf:"bytes,3,opt,name=ranges" json:"ranges,omitempty"`
	Set              *Value_Set    `protobuf:"bytes,4,opt,name=set" json:"set,omitempty"`
	Text             *Value_Text   `protobuf:"bytes,5,opt,name=text" json:"text,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Value) Reset()         { *m = Value{} }
func (m *Value) String() string { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()    {}

func (m *Value) GetType() Value_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Value_SCALAR
}

func (m *Value) GetScalar() *Value_Scalar {
	if m != nil {
		return m.Scalar
	}
	return nil
}

func (m *Value) GetRanges() *Value_Ranges {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *Value) GetSet() *Value_Set {
	if m != nil {
		return m.Set
	}
	return nil
}

func (m *Value) GetText() *Value_Text {
	if m != nil {
		return m.Text
	}
	return nil
}

type Value_Scalar struct {
	Value            *float64 `protobuf:"fixed64,1,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Value_Scalar) Reset()         { *m = Value_Scalar{} }
func (m *Value_Scalar) String() string { return proto.CompactTextString(m) }
func (*Value_Scalar) ProtoMessage()    {}

func (m *Value_Scalar) GetValue() float64 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

type Value_Range struct {
	Begin            *uint64 `protobuf:"varint,1,req,name=begin" json:"begin,omitempty"`
	End              *uint64 `protobuf:"varint,2,req,name=end" json:"end,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Value_Range) Reset()         { *m = Value_Range{} }
func (m *Value_Range) String() string { return proto.CompactTextString(m) }
func (*Value_Range) ProtoMessage()    {}

func (m *Value_Range) GetBegin() uint64 {
	if m != nil && m.Begin != nil {
		return *m.Begin
	}
	return 0
}

func (m *Value_Range) GetEnd() uint64 {
	if m != nil && m.End != nil {
		return *m.End
	}
	return 0
}

type Value_Ranges struct {
	Range            []*Value_Range `protobuf:"bytes,1,rep,name=range" json:"range,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Value_Ranges) Reset()         { *m = Value_Ranges{} }
func (m *Value_Ranges) String() string { return proto.CompactTextString(m) }
func (*Value_Ranges) ProtoMessage()    {}

func (m *Value_Ranges) GetRange() []*Value_Range {
	if m != nil {
		return m.Range
	}
	return nil
}

type Value_Set struct {
	Item             []string `protobuf:"bytes,1,rep,name=item" json:"item,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Value_Set) Reset()         { *m = Value_Set{} }
func (m *Value_Set) String() string { return proto.CompactTextString(m) }
func (*Value_Set) ProtoMessage()    {}

func (m *Value_Set) GetItem() []string {
	if m != nil {
		return m.Item
	}
	return nil
}

type Value_Text struct {
	Value            *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Value_Text) Reset()         { *m = Value_Text{} }
func (m *Value_Text) String() string { return proto.CompactTextString(m) }
func (*Value_Text) ProtoMessage()    {}

func (m *Value_Text) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// Describes an attribute that can be set on a machine. For now,
// attributes and resources share the same "value" type, but this may
// change in the future and attributes may only be string based.
type Attribute struct {
	Name             *string       `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Type             *Value_Type   `protobuf:"varint,2,req,name=type,enum=mesosproto.Value_Type" json:"type,omitempty"`
	Scalar           *Value_Scalar `protobuf:"bytes,3,opt,name=scalar" json:"scalar,omitempty"`
	Ranges           *Value_Ranges `protobuf:"bytes,4,opt,name=ranges" json:"ranges,omitempty"`
	Set              *Value_Set    `protobuf:"bytes,6,opt,name=set" json:"set,omitempty"`
	Text             *Value_Text   `protobuf:"bytes,5,opt,name=text" json:"text,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Attribute) Reset()         { *m = Attribute{} }
func (m *Attribute) String() string { return proto.CompactTextString(m) }
func (*Attribute) ProtoMessage()    {}

func (m *Attribute) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Attribute) GetType() Value_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Value_SCALAR
}

func (m *Attribute) GetScalar() *Value_Scalar {
	if m != nil {
		return m.Scalar
	}
	return nil
}

func (m *Attribute) GetRanges() *Value_Ranges {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *Attribute) GetSet() *Value_Set {
	if m != nil {
		return m.Set
	}
	return nil
}

func (m *Attribute) GetText() *Value_Text {
	if m != nil {
		return m.Text
	}
	return nil
}

// *
// Describes a resource on a machine. A resource can take on one of
// three types: scalar (double), a list of finite and discrete ranges
// (e.g., [1-10, 20-30]), or a set of items. A resource is described
// using the standard protocol buffer "union" trick.
//
// TODO(benh): Add better support for "expected" resources (e.g.,
// cpus, memory, disk, network).
type Resource struct {
	Name             *string       `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Type             *Value_Type   `protobuf:"varint,2,req,name=type,enum=mesosproto.Value_Type" json:"type,omitempty"`
	Scalar           *Value_Scalar `protobuf:"bytes,3,opt,name=scalar" json:"scalar,omitempty"`
	Ranges           *Value_Ranges `protobuf:"bytes,4,opt,name=ranges" json:"ranges,omitempty"`
	Set              *Value_Set    `protobuf:"bytes,5,opt,name=set" json:"set,omitempty"`
	Role             *string       `protobuf:"bytes,6,opt,name=role,def=*" json:"role,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Resource) Reset()         { *m = Resource{} }
func (m *Resource) String() string { return proto.CompactTextString(m) }
func (*Resource) ProtoMessage()    {}

const Default_Resource_Role string = "*"

func (m *Resource) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Resource) GetType() Value_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Value_SCALAR
}

func (m *Resource) GetScalar() *Value_Scalar {
	if m != nil {
		return m.Scalar
	}
	return nil
}

func (m *Resource) GetRanges() *Value_Ranges {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *Resource) GetSet() *Value_Set {
	if m != nil {
		return m.Set
	}
	return nil
}

func (m *Resource) GetRole() string {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return Default_Resource_Role
}

//
// A snapshot of resource usage statistics.
type ResourceStatistics struct {
	Timestamp *float64 `protobuf:"fixed64,1,req,name=timestamp" json:"timestamp,omitempty"`
	// CPU Usage Information:
	// Total CPU time spent in user mode, and kernel mode.
	CpusUserTimeSecs   *float64 `protobuf:"fixed64,2,opt,name=cpus_user_time_secs" json:"cpus_user_time_secs,omitempty"`
	CpusSystemTimeSecs *float64 `protobuf:"fixed64,3,opt,name=cpus_system_time_secs" json:"cpus_system_time_secs,omitempty"`
	// Number of CPUs allocated.
	CpusLimit *float64 `protobuf:"fixed64,4,opt,name=cpus_limit" json:"cpus_limit,omitempty"`
	// cpu.stat on process throttling (for contention issues).
	CpusNrPeriods         *uint32  `protobuf:"varint,7,opt,name=cpus_nr_periods" json:"cpus_nr_periods,omitempty"`
	CpusNrThrottled       *uint32  `protobuf:"varint,8,opt,name=cpus_nr_throttled" json:"cpus_nr_throttled,omitempty"`
	CpusThrottledTimeSecs *float64 `protobuf:"fixed64,9,opt,name=cpus_throttled_time_secs" json:"cpus_throttled_time_secs,omitempty"`
	// Memory Usage Information:
	MemRssBytes *uint64 `protobuf:"varint,5,opt,name=mem_rss_bytes" json:"mem_rss_bytes,omitempty"`
	// Amount of memory resources allocated.
	MemLimitBytes *uint64 `protobuf:"varint,6,opt,name=mem_limit_bytes" json:"mem_limit_bytes,omitempty"`
	// Broken out memory usage information (files, anonymous, and mmaped files)
	MemFileBytes       *uint64 `protobuf:"varint,10,opt,name=mem_file_bytes" json:"mem_file_bytes,omitempty"`
	MemAnonBytes       *uint64 `protobuf:"varint,11,opt,name=mem_anon_bytes" json:"mem_anon_bytes,omitempty"`
	MemMappedFileBytes *uint64 `protobuf:"varint,12,opt,name=mem_mapped_file_bytes" json:"mem_mapped_file_bytes,omitempty"`
	// Perf statistics.
	Perf *PerfStatistics `protobuf:"bytes,13,opt,name=perf" json:"perf,omitempty"`
	// Network Usage Information:
	NetRxPackets *uint64 `protobuf:"varint,14,opt,name=net_rx_packets" json:"net_rx_packets,omitempty"`
	NetRxBytes   *uint64 `protobuf:"varint,15,opt,name=net_rx_bytes" json:"net_rx_bytes,omitempty"`
	NetRxErrors  *uint64 `protobuf:"varint,16,opt,name=net_rx_errors" json:"net_rx_errors,omitempty"`
	NetRxDropped *uint64 `protobuf:"varint,17,opt,name=net_rx_dropped" json:"net_rx_dropped,omitempty"`
	NetTxPackets *uint64 `protobuf:"varint,18,opt,name=net_tx_packets" json:"net_tx_packets,omitempty"`
	NetTxBytes   *uint64 `protobuf:"varint,19,opt,name=net_tx_bytes" json:"net_tx_bytes,omitempty"`
	NetTxErrors  *uint64 `protobuf:"varint,20,opt,name=net_tx_errors" json:"net_tx_errors,omitempty"`
	NetTxDropped *uint64 `protobuf:"varint,21,opt,name=net_tx_dropped" json:"net_tx_dropped,omitempty"`
	// The kernel keeps track of RTT (round-trip time) for its TCP
	// sockets. We gather all the RTTs (except for local connections) of
	// a container and use its median as a way to correlate back to the
	// latency of a container.
	NetTcpRttMedianUsecs *float64 `protobuf:"fixed64,22,opt,name=net_tcp_rtt_median_usecs" json:"net_tcp_rtt_median_usecs,omitempty"`
	XXX_unrecognized     []byte   `json:"-"`
}

func (m *ResourceStatistics) Reset()         { *m = ResourceStatistics{} }
func (m *ResourceStatistics) String() string { return proto.CompactTextString(m) }
func (*ResourceStatistics) ProtoMessage()    {}

func (m *ResourceStatistics) GetTimestamp() float64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *ResourceStatistics) GetCpusUserTimeSecs() float64 {
	if m != nil && m.CpusUserTimeSecs != nil {
		return *m.CpusUserTimeSecs
	}
	return 0
}

func (m *ResourceStatistics) GetCpusSystemTimeSecs() float64 {
	if m != nil && m.CpusSystemTimeSecs != nil {
		return *m.CpusSystemTimeSecs
	}
	return 0
}

func (m *ResourceStatistics) GetCpusLimit() float64 {
	if m != nil && m.CpusLimit != nil {
		return *m.CpusLimit
	}
	return 0
}

func (m *ResourceStatistics) GetCpusNrPeriods() uint32 {
	if m != nil && m.CpusNrPeriods != nil {
		return *m.CpusNrPeriods
	}
	return 0
}

func (m *ResourceStatistics) GetCpusNrThrottled() uint32 {
	if m != nil && m.CpusNrThrottled != nil {
		return *m.CpusNrThrottled
	}
	return 0
}

func (m *ResourceStatistics) GetCpusThrottledTimeSecs() float64 {
	if m != nil && m.CpusThrottledTimeSecs != nil {
		return *m.CpusThrottledTimeSecs
	}
	return 0
}

func (m *ResourceStatistics) GetMemRssBytes() uint64 {
	if m != nil && m.MemRssBytes != nil {
		return *m.MemRssBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemLimitBytes() uint64 {
	if m != nil && m.MemLimitBytes != nil {
		return *m.MemLimitBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemFileBytes() uint64 {
	if m != nil && m.MemFileBytes != nil {
		return *m.MemFileBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemAnonBytes() uint64 {
	if m != nil && m.MemAnonBytes != nil {
		return *m.MemAnonBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemMappedFileBytes() uint64 {
	if m != nil && m.MemMappedFileBytes != nil {
		return *m.MemMappedFileBytes
	}
	return 0
}

func (m *ResourceStatistics) GetPerf() *PerfStatistics {
	if m != nil {
		return m.Perf
	}
	return nil
}

func (m *ResourceStatistics) GetNetRxPackets() uint64 {
	if m != nil && m.NetRxPackets != nil {
		return *m.NetRxPackets
	}
	return 0
}

func (m *ResourceStatistics) GetNetRxBytes() uint64 {
	if m != nil && m.NetRxBytes != nil {
		return *m.NetRxBytes
	}
	return 0
}

func (m *ResourceStatistics) GetNetRxErrors() uint64 {
	if m != nil && m.NetRxErrors != nil {
		return *m.NetRxErrors
	}
	return 0
}

func (m *ResourceStatistics) GetNetRxDropped() uint64 {
	if m != nil && m.NetRxDropped != nil {
		return *m.NetRxDropped
	}
	return 0
}

func (m *ResourceStatistics) GetNetTxPackets() uint64 {
	if m != nil && m.NetTxPackets != nil {
		return *m.NetTxPackets
	}
	return 0
}

func (m *ResourceStatistics) GetNetTxBytes() uint64 {
	if m != nil && m.NetTxBytes != nil {
		return *m.NetTxBytes
	}
	return 0
}

func (m *ResourceStatistics) GetNetTxErrors() uint64 {
	if m != nil && m.NetTxErrors != nil {
		return *m.NetTxErrors
	}
	return 0
}

func (m *ResourceStatistics) GetNetTxDropped() uint64 {
	if m != nil && m.NetTxDropped != nil {
		return *m.NetTxDropped
	}
	return 0
}

func (m *ResourceStatistics) GetNetTcpRttMedianUsecs() float64 {
	if m != nil && m.NetTcpRttMedianUsecs != nil {
		return *m.NetTcpRttMedianUsecs
	}
	return 0
}

// *
// Describes a snapshot of the resource usage for an executor.
//
// TODO(bmahler): Note that we want to be sending this information
// to the master, and subsequently to the relevant scheduler. So
// this proto is designed to be easy for the scheduler to use, this
// is why we provide the slave id, executor info / task info.
type ResourceUsage struct {
	SlaveId      *SlaveID     `protobuf:"bytes,1,req,name=slave_id" json:"slave_id,omitempty"`
	FrameworkId  *FrameworkID `protobuf:"bytes,2,req,name=framework_id" json:"framework_id,omitempty"`
	ExecutorId   *ExecutorID  `protobuf:"bytes,3,opt,name=executor_id" json:"executor_id,omitempty"`
	ExecutorName *string      `protobuf:"bytes,4,opt,name=executor_name" json:"executor_name,omitempty"`
	TaskId       *TaskID      `protobuf:"bytes,5,opt,name=task_id" json:"task_id,omitempty"`
	// If missing, the isolation module cannot provide resource usage.
	Statistics       *ResourceStatistics `protobuf:"bytes,6,opt,name=statistics" json:"statistics,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *ResourceUsage) Reset()         { *m = ResourceUsage{} }
func (m *ResourceUsage) String() string { return proto.CompactTextString(m) }
func (*ResourceUsage) ProtoMessage()    {}

func (m *ResourceUsage) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *ResourceUsage) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *ResourceUsage) GetExecutorId() *ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

func (m *ResourceUsage) GetExecutorName() string {
	if m != nil && m.ExecutorName != nil {
		return *m.ExecutorName
	}
	return ""
}

func (m *ResourceUsage) GetTaskId() *TaskID {
	if m != nil {
		return m.TaskId
	}
	return nil
}

func (m *ResourceUsage) GetStatistics() *ResourceStatistics {
	if m != nil {
		return m.Statistics
	}
	return nil
}

// *
// Describes a sample of events from "perf stat". Only available on
// Linux.
//
// NOTE: Each optional field matches the name of a perf event (see
// "perf list") with the following changes:
// 1. Names are downcased.
// 2. Hyphens ('-') are replaced with underscores ('_').
// 3. Events with alternate names use the name "perf stat" returns,
//    e.g., for the event "cycles OR cpu-cycles" perf always returns
//    cycles.
type PerfStatistics struct {
	Timestamp *float64 `protobuf:"fixed64,1,req,name=timestamp" json:"timestamp,omitempty"`
	Duration  *float64 `protobuf:"fixed64,2,req,name=duration" json:"duration,omitempty"`
	// Hardware event.
	Cycles                *uint64 `protobuf:"varint,3,opt,name=cycles" json:"cycles,omitempty"`
	StalledCyclesFrontend *uint64 `protobuf:"varint,4,opt,name=stalled_cycles_frontend" json:"stalled_cycles_frontend,omitempty"`
	StalledCyclesBackend  *uint64 `protobuf:"varint,5,opt,name=stalled_cycles_backend" json:"stalled_cycles_backend,omitempty"`
	Instructions          *uint64 `protobuf:"varint,6,opt,name=instructions" json:"instructions,omitempty"`
	CacheReferences       *uint64 `protobuf:"varint,7,opt,name=cache_references" json:"cache_references,omitempty"`
	CacheMisses           *uint64 `protobuf:"varint,8,opt,name=cache_misses" json:"cache_misses,omitempty"`
	Branches              *uint64 `protobuf:"varint,9,opt,name=branches" json:"branches,omitempty"`
	BranchMisses          *uint64 `protobuf:"varint,10,opt,name=branch_misses" json:"branch_misses,omitempty"`
	BusCycles             *uint64 `protobuf:"varint,11,opt,name=bus_cycles" json:"bus_cycles,omitempty"`
	RefCycles             *uint64 `protobuf:"varint,12,opt,name=ref_cycles" json:"ref_cycles,omitempty"`
	// Software event.
	CpuClock        *float64 `protobuf:"fixed64,13,opt,name=cpu_clock" json:"cpu_clock,omitempty"`
	TaskClock       *float64 `protobuf:"fixed64,14,opt,name=task_clock" json:"task_clock,omitempty"`
	PageFaults      *uint64  `protobuf:"varint,15,opt,name=page_faults" json:"page_faults,omitempty"`
	MinorFaults     *uint64  `protobuf:"varint,16,opt,name=minor_faults" json:"minor_faults,omitempty"`
	MajorFaults     *uint64  `protobuf:"varint,17,opt,name=major_faults" json:"major_faults,omitempty"`
	ContextSwitches *uint64  `protobuf:"varint,18,opt,name=context_switches" json:"context_switches,omitempty"`
	CpuMigrations   *uint64  `protobuf:"varint,19,opt,name=cpu_migrations" json:"cpu_migrations,omitempty"`
	AlignmentFaults *uint64  `protobuf:"varint,20,opt,name=alignment_faults" json:"alignment_faults,omitempty"`
	EmulationFaults *uint64  `protobuf:"varint,21,opt,name=emulation_faults" json:"emulation_faults,omitempty"`
	// Hardware cache event.
	L1DcacheLoads          *uint64 `protobuf:"varint,22,opt,name=l1_dcache_loads" json:"l1_dcache_loads,omitempty"`
	L1DcacheLoadMisses     *uint64 `protobuf:"varint,23,opt,name=l1_dcache_load_misses" json:"l1_dcache_load_misses,omitempty"`
	L1DcacheStores         *uint64 `protobuf:"varint,24,opt,name=l1_dcache_stores" json:"l1_dcache_stores,omitempty"`
	L1DcacheStoreMisses    *uint64 `protobuf:"varint,25,opt,name=l1_dcache_store_misses" json:"l1_dcache_store_misses,omitempty"`
	L1DcachePrefetches     *uint64 `protobuf:"varint,26,opt,name=l1_dcache_prefetches" json:"l1_dcache_prefetches,omitempty"`
	L1DcachePrefetchMisses *uint64 `protobuf:"varint,27,opt,name=l1_dcache_prefetch_misses" json:"l1_dcache_prefetch_misses,omitempty"`
	L1IcacheLoads          *uint64 `protobuf:"varint,28,opt,name=l1_icache_loads" json:"l1_icache_loads,omitempty"`
	L1IcacheLoadMisses     *uint64 `protobuf:"varint,29,opt,name=l1_icache_load_misses" json:"l1_icache_load_misses,omitempty"`
	L1IcachePrefetches     *uint64 `protobuf:"varint,30,opt,name=l1_icache_prefetches" json:"l1_icache_prefetches,omitempty"`
	L1IcachePrefetchMisses *uint64 `protobuf:"varint,31,opt,name=l1_icache_prefetch_misses" json:"l1_icache_prefetch_misses,omitempty"`
	LlcLoads               *uint64 `protobuf:"varint,32,opt,name=llc_loads" json:"llc_loads,omitempty"`
	LlcLoadMisses          *uint64 `protobuf:"varint,33,opt,name=llc_load_misses" json:"llc_load_misses,omitempty"`
	LlcStores              *uint64 `protobuf:"varint,34,opt,name=llc_stores" json:"llc_stores,omitempty"`
	LlcStoreMisses         *uint64 `protobuf:"varint,35,opt,name=llc_store_misses" json:"llc_store_misses,omitempty"`
	LlcPrefetches          *uint64 `protobuf:"varint,36,opt,name=llc_prefetches" json:"llc_prefetches,omitempty"`
	LlcPrefetchMisses      *uint64 `protobuf:"varint,37,opt,name=llc_prefetch_misses" json:"llc_prefetch_misses,omitempty"`
	DtlbLoads              *uint64 `protobuf:"varint,38,opt,name=dtlb_loads" json:"dtlb_loads,omitempty"`
	DtlbLoadMisses         *uint64 `protobuf:"varint,39,opt,name=dtlb_load_misses" json:"dtlb_load_misses,omitempty"`
	DtlbStores             *uint64 `protobuf:"varint,40,opt,name=dtlb_stores" json:"dtlb_stores,omitempty"`
	DtlbStoreMisses        *uint64 `protobuf:"varint,41,opt,name=dtlb_store_misses" json:"dtlb_store_misses,omitempty"`
	DtlbPrefetches         *uint64 `protobuf:"varint,42,opt,name=dtlb_prefetches" json:"dtlb_prefetches,omitempty"`
	DtlbPrefetchMisses     *uint64 `protobuf:"varint,43,opt,name=dtlb_prefetch_misses" json:"dtlb_prefetch_misses,omitempty"`
	ItlbLoads              *uint64 `protobuf:"varint,44,opt,name=itlb_loads" json:"itlb_loads,omitempty"`
	ItlbLoadMisses         *uint64 `protobuf:"varint,45,opt,name=itlb_load_misses" json:"itlb_load_misses,omitempty"`
	BranchLoads            *uint64 `protobuf:"varint,46,opt,name=branch_loads" json:"branch_loads,omitempty"`
	BranchLoadMisses       *uint64 `protobuf:"varint,47,opt,name=branch_load_misses" json:"branch_load_misses,omitempty"`
	NodeLoads              *uint64 `protobuf:"varint,48,opt,name=node_loads" json:"node_loads,omitempty"`
	NodeLoadMisses         *uint64 `protobuf:"varint,49,opt,name=node_load_misses" json:"node_load_misses,omitempty"`
	NodeStores             *uint64 `protobuf:"varint,50,opt,name=node_stores" json:"node_stores,omitempty"`
	NodeStoreMisses        *uint64 `protobuf:"varint,51,opt,name=node_store_misses" json:"node_store_misses,omitempty"`
	NodePrefetches         *uint64 `protobuf:"varint,52,opt,name=node_prefetches" json:"node_prefetches,omitempty"`
	NodePrefetchMisses     *uint64 `protobuf:"varint,53,opt,name=node_prefetch_misses" json:"node_prefetch_misses,omitempty"`
	XXX_unrecognized       []byte  `json:"-"`
}

func (m *PerfStatistics) Reset()         { *m = PerfStatistics{} }
func (m *PerfStatistics) String() string { return proto.CompactTextString(m) }
func (*PerfStatistics) ProtoMessage()    {}

func (m *PerfStatistics) GetTimestamp() float64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *PerfStatistics) GetDuration() float64 {
	if m != nil && m.Duration != nil {
		return *m.Duration
	}
	return 0
}

func (m *PerfStatistics) GetCycles() uint64 {
	if m != nil && m.Cycles != nil {
		return *m.Cycles
	}
	return 0
}

func (m *PerfStatistics) GetStalledCyclesFrontend() uint64 {
	if m != nil && m.StalledCyclesFrontend != nil {
		return *m.StalledCyclesFrontend
	}
	return 0
}

func (m *PerfStatistics) GetStalledCyclesBackend() uint64 {
	if m != nil && m.StalledCyclesBackend != nil {
		return *m.StalledCyclesBackend
	}
	return 0
}

func (m *PerfStatistics) GetInstructions() uint64 {
	if m != nil && m.Instructions != nil {
		return *m.Instructions
	}
	return 0
}

func (m *PerfStatistics) GetCacheReferences() uint64 {
	if m != nil && m.CacheReferences != nil {
		return *m.CacheReferences
	}
	return 0
}

func (m *PerfStatistics) GetCacheMisses() uint64 {
	if m != nil && m.CacheMisses != nil {
		return *m.CacheMisses
	}
	return 0
}

func (m *PerfStatistics) GetBranches() uint64 {
	if m != nil && m.Branches != nil {
		return *m.Branches
	}
	return 0
}

func (m *PerfStatistics) GetBranchMisses() uint64 {
	if m != nil && m.BranchMisses != nil {
		return *m.BranchMisses
	}
	return 0
}

func (m *PerfStatistics) GetBusCycles() uint64 {
	if m != nil && m.BusCycles != nil {
		return *m.BusCycles
	}
	return 0
}

func (m *PerfStatistics) GetRefCycles() uint64 {
	if m != nil && m.RefCycles != nil {
		return *m.RefCycles
	}
	return 0
}

func (m *PerfStatistics) GetCpuClock() float64 {
	if m != nil && m.CpuClock != nil {
		return *m.CpuClock
	}
	return 0
}

func (m *PerfStatistics) GetTaskClock() float64 {
	if m != nil && m.TaskClock != nil {
		return *m.TaskClock
	}
	return 0
}

func (m *PerfStatistics) GetPageFaults() uint64 {
	if m != nil && m.PageFaults != nil {
		return *m.PageFaults
	}
	return 0
}

func (m *PerfStatistics) GetMinorFaults() uint64 {
	if m != nil && m.MinorFaults != nil {
		return *m.MinorFaults
	}
	return 0
}

func (m *PerfStatistics) GetMajorFaults() uint64 {
	if m != nil && m.MajorFaults != nil {
		return *m.MajorFaults
	}
	return 0
}

func (m *PerfStatistics) GetContextSwitches() uint64 {
	if m != nil && m.ContextSwitches != nil {
		return *m.ContextSwitches
	}
	return 0
}

func (m *PerfStatistics) GetCpuMigrations() uint64 {
	if m != nil && m.CpuMigrations != nil {
		return *m.CpuMigrations
	}
	return 0
}

func (m *PerfStatistics) GetAlignmentFaults() uint64 {
	if m != nil && m.AlignmentFaults != nil {
		return *m.AlignmentFaults
	}
	return 0
}

func (m *PerfStatistics) GetEmulationFaults() uint64 {
	if m != nil && m.EmulationFaults != nil {
		return *m.EmulationFaults
	}
	return 0
}

func (m *PerfStatistics) GetL1DcacheLoads() uint64 {
	if m != nil && m.L1DcacheLoads != nil {
		return *m.L1DcacheLoads
	}
	return 0
}

func (m *PerfStatistics) GetL1DcacheLoadMisses() uint64 {
	if m != nil && m.L1DcacheLoadMisses != nil {
		return *m.L1DcacheLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetL1DcacheStores() uint64 {
	if m != nil && m.L1DcacheStores != nil {
		return *m.L1DcacheStores
	}
	return 0
}

func (m *PerfStatistics) GetL1DcacheStoreMisses() uint64 {
	if m != nil && m.L1DcacheStoreMisses != nil {
		return *m.L1DcacheStoreMisses
	}
	return 0
}

func (m *PerfStatistics) GetL1DcachePrefetches() uint64 {
	if m != nil && m.L1DcachePrefetches != nil {
		return *m.L1DcachePrefetches
	}
	return 0
}

func (m *PerfStatistics) GetL1DcachePrefetchMisses() uint64 {
	if m != nil && m.L1DcachePrefetchMisses != nil {
		return *m.L1DcachePrefetchMisses
	}
	return 0
}

func (m *PerfStatistics) GetL1IcacheLoads() uint64 {
	if m != nil && m.L1IcacheLoads != nil {
		return *m.L1IcacheLoads
	}
	return 0
}

func (m *PerfStatistics) GetL1IcacheLoadMisses() uint64 {
	if m != nil && m.L1IcacheLoadMisses != nil {
		return *m.L1IcacheLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetL1IcachePrefetches() uint64 {
	if m != nil && m.L1IcachePrefetches != nil {
		return *m.L1IcachePrefetches
	}
	return 0
}

func (m *PerfStatistics) GetL1IcachePrefetchMisses() uint64 {
	if m != nil && m.L1IcachePrefetchMisses != nil {
		return *m.L1IcachePrefetchMisses
	}
	return 0
}

func (m *PerfStatistics) GetLlcLoads() uint64 {
	if m != nil && m.LlcLoads != nil {
		return *m.LlcLoads
	}
	return 0
}

func (m *PerfStatistics) GetLlcLoadMisses() uint64 {
	if m != nil && m.LlcLoadMisses != nil {
		return *m.LlcLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetLlcStores() uint64 {
	if m != nil && m.LlcStores != nil {
		return *m.LlcStores
	}
	return 0
}

func (m *PerfStatistics) GetLlcStoreMisses() uint64 {
	if m != nil && m.LlcStoreMisses != nil {
		return *m.LlcStoreMisses
	}
	return 0
}

func (m *PerfStatistics) GetLlcPrefetches() uint64 {
	if m != nil && m.LlcPrefetches != nil {
		return *m.LlcPrefetches
	}
	return 0
}

func (m *PerfStatistics) GetLlcPrefetchMisses() uint64 {
	if m != nil && m.LlcPrefetchMisses != nil {
		return *m.LlcPrefetchMisses
	}
	return 0
}

func (m *PerfStatistics) GetDtlbLoads() uint64 {
	if m != nil && m.DtlbLoads != nil {
		return *m.DtlbLoads
	}
	return 0
}

func (m *PerfStatistics) GetDtlbLoadMisses() uint64 {
	if m != nil && m.DtlbLoadMisses != nil {
		return *m.DtlbLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetDtlbStores() uint64 {
	if m != nil && m.DtlbStores != nil {
		return *m.DtlbStores
	}
	return 0
}

func (m *PerfStatistics) GetDtlbStoreMisses() uint64 {
	if m != nil && m.DtlbStoreMisses != nil {
		return *m.DtlbStoreMisses
	}
	return 0
}

func (m *PerfStatistics) GetDtlbPrefetches() uint64 {
	if m != nil && m.DtlbPrefetches != nil {
		return *m.DtlbPrefetches
	}
	return 0
}

func (m *PerfStatistics) GetDtlbPrefetchMisses() uint64 {
	if m != nil && m.DtlbPrefetchMisses != nil {
		return *m.DtlbPrefetchMisses
	}
	return 0
}

func (m *PerfStatistics) GetItlbLoads() uint64 {
	if m != nil && m.ItlbLoads != nil {
		return *m.ItlbLoads
	}
	return 0
}

func (m *PerfStatistics) GetItlbLoadMisses() uint64 {
	if m != nil && m.ItlbLoadMisses != nil {
		return *m.ItlbLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetBranchLoads() uint64 {
	if m != nil && m.BranchLoads != nil {
		return *m.BranchLoads
	}
	return 0
}

func (m *PerfStatistics) GetBranchLoadMisses() uint64 {
	if m != nil && m.BranchLoadMisses != nil {
		return *m.BranchLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetNodeLoads() uint64 {
	if m != nil && m.NodeLoads != nil {
		return *m.NodeLoads
	}
	return 0
}

func (m *PerfStatistics) GetNodeLoadMisses() uint64 {
	if m != nil && m.NodeLoadMisses != nil {
		return *m.NodeLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetNodeStores() uint64 {
	if m != nil && m.NodeStores != nil {
		return *m.NodeStores
	}
	return 0
}

func (m *PerfStatistics) GetNodeStoreMisses() uint64 {
	if m != nil && m.NodeStoreMisses != nil {
		return *m.NodeStoreMisses
	}
	return 0
}

func (m *PerfStatistics) GetNodePrefetches() uint64 {
	if m != nil && m.NodePrefetches != nil {
		return *m.NodePrefetches
	}
	return 0
}

func (m *PerfStatistics) GetNodePrefetchMisses() uint64 {
	if m != nil && m.NodePrefetchMisses != nil {
		return *m.NodePrefetchMisses
	}
	return 0
}

// *
// Describes a request for resources that can be used by a framework
// to proactively influence the allocator.  If 'slave_id' is provided
// then this request is assumed to only apply to resources on that
// slave.
type Request struct {
	SlaveId          *SlaveID    `protobuf:"bytes,1,opt,name=slave_id" json:"slave_id,omitempty"`
	Resources        []*Resource `protobuf:"bytes,2,rep,name=resources" json:"resources,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}

func (m *Request) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *Request) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

// *
// Describes some resources available on a slave. An offer only
// contains resources from a single slave.
type Offer struct {
	Id               *OfferID      `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	FrameworkId      *FrameworkID  `protobuf:"bytes,2,req,name=framework_id" json:"framework_id,omitempty"`
	SlaveId          *SlaveID      `protobuf:"bytes,3,req,name=slave_id" json:"slave_id,omitempty"`
	Hostname         *string       `protobuf:"bytes,4,req,name=hostname" json:"hostname,omitempty"`
	Resources        []*Resource   `protobuf:"bytes,5,rep,name=resources" json:"resources,omitempty"`
	Attributes       []*Attribute  `protobuf:"bytes,7,rep,name=attributes" json:"attributes,omitempty"`
	ExecutorIds      []*ExecutorID `protobuf:"bytes,6,rep,name=executor_ids" json:"executor_ids,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Offer) Reset()         { *m = Offer{} }
func (m *Offer) String() string { return proto.CompactTextString(m) }
func (*Offer) ProtoMessage()    {}

func (m *Offer) GetId() *OfferID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Offer) GetFrameworkId() *FrameworkID {
	if m != nil {
		return m.FrameworkId
	}
	return nil
}

func (m *Offer) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *Offer) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *Offer) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *Offer) GetAttributes() []*Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Offer) GetExecutorIds() []*ExecutorID {
	if m != nil {
		return m.ExecutorIds
	}
	return nil
}

// *
// Describes a task. Passed from the scheduler all the way to an
// executor (see SchedulerDriver::launchTasks and
// Executor::launchTask). Either ExecutorInfo or CommandInfo should be set.
// A different executor can be used to launch this task, and subsequent tasks
// meant for the same executor can reuse the same ExecutorInfo struct.
type TaskInfo struct {
	Name      *string       `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	TaskId    *TaskID       `protobuf:"bytes,2,req,name=task_id" json:"task_id,omitempty"`
	SlaveId   *SlaveID      `protobuf:"bytes,3,req,name=slave_id" json:"slave_id,omitempty"`
	Resources []*Resource   `protobuf:"bytes,4,rep,name=resources" json:"resources,omitempty"`
	Executor  *ExecutorInfo `protobuf:"bytes,5,opt,name=executor" json:"executor,omitempty"`
	Command   *CommandInfo  `protobuf:"bytes,7,opt,name=command" json:"command,omitempty"`
	// Task provided with a container will launch the container as part
	// of this task paired with the task's CommandInfo.
	Container *ContainerInfo `protobuf:"bytes,9,opt,name=container" json:"container,omitempty"`
	Data      []byte         `protobuf:"bytes,6,opt,name=data" json:"data,omitempty"`
	// A health check for the task (currently in *alpha* and initial
	// support will only be for TaskInfo's that have a CommandInfo).
	HealthCheck      *HealthCheck `protobuf:"bytes,8,opt,name=health_check" json:"health_check,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *TaskInfo) Reset()         { *m = TaskInfo{} }
func (m *TaskInfo) String() string { return proto.CompactTextString(m) }
func (*TaskInfo) ProtoMessage()    {}

func (m *TaskInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *TaskInfo) GetTaskId() *TaskID {
	if m != nil {
		return m.TaskId
	}
	return nil
}

func (m *TaskInfo) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *TaskInfo) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *TaskInfo) GetExecutor() *ExecutorInfo {
	if m != nil {
		return m.Executor
	}
	return nil
}

func (m *TaskInfo) GetCommand() *CommandInfo {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *TaskInfo) GetContainer() *ContainerInfo {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *TaskInfo) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *TaskInfo) GetHealthCheck() *HealthCheck {
	if m != nil {
		return m.HealthCheck
	}
	return nil
}

// *
// Describes the current status of a task.
type TaskStatus struct {
	TaskId     *TaskID     `protobuf:"bytes,1,req,name=task_id" json:"task_id,omitempty"`
	State      *TaskState  `protobuf:"varint,2,req,name=state,enum=mesosproto.TaskState" json:"state,omitempty"`
	Message    *string     `protobuf:"bytes,4,opt,name=message" json:"message,omitempty"`
	Data       []byte      `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
	SlaveId    *SlaveID    `protobuf:"bytes,5,opt,name=slave_id" json:"slave_id,omitempty"`
	ExecutorId *ExecutorID `protobuf:"bytes,7,opt,name=executor_id" json:"executor_id,omitempty"`
	Timestamp  *float64    `protobuf:"fixed64,6,opt,name=timestamp" json:"timestamp,omitempty"`
	// Describes whether the task has been determined to be healthy
	// (true) or unhealthy (false) according to the HealthCheck field in
	// the command info.
	Healthy          *bool  `protobuf:"varint,8,opt,name=healthy" json:"healthy,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TaskStatus) Reset()         { *m = TaskStatus{} }
func (m *TaskStatus) String() string { return proto.CompactTextString(m) }
func (*TaskStatus) ProtoMessage()    {}

func (m *TaskStatus) GetTaskId() *TaskID {
	if m != nil {
		return m.TaskId
	}
	return nil
}

func (m *TaskStatus) GetState() TaskState {
	if m != nil && m.State != nil {
		return *m.State
	}
	return TaskState_TASK_STAGING
}

func (m *TaskStatus) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func (m *TaskStatus) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *TaskStatus) GetSlaveId() *SlaveID {
	if m != nil {
		return m.SlaveId
	}
	return nil
}

func (m *TaskStatus) GetExecutorId() *ExecutorID {
	if m != nil {
		return m.ExecutorId
	}
	return nil
}

func (m *TaskStatus) GetTimestamp() float64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *TaskStatus) GetHealthy() bool {
	if m != nil && m.Healthy != nil {
		return *m.Healthy
	}
	return false
}

// *
// Describes possible filters that can be applied to unused resources
// (see SchedulerDriver::launchTasks) to influence the allocator.
type Filters struct {
	// Time to consider unused resources refused. Note that all unused
	// resources will be considered refused and use the default value
	// (below) regardless of whether Filters was passed to
	// SchedulerDriver::launchTasks. You MUST pass Filters with this
	// field set to change this behavior (i.e., get another offer which
	// includes unused resources sooner or later than the default).
	RefuseSeconds    *float64 `protobuf:"fixed64,1,opt,name=refuse_seconds,def=5" json:"refuse_seconds,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Filters) Reset()         { *m = Filters{} }
func (m *Filters) String() string { return proto.CompactTextString(m) }
func (*Filters) ProtoMessage()    {}

const Default_Filters_RefuseSeconds float64 = 5

func (m *Filters) GetRefuseSeconds() float64 {
	if m != nil && m.RefuseSeconds != nil {
		return *m.RefuseSeconds
	}
	return Default_Filters_RefuseSeconds
}

// *
// Describes a collection of environment variables. This is used with
// CommandInfo in order to set environment variables before running a
// command.
type Environment struct {
	Variables        []*Environment_Variable `protobuf:"bytes,1,rep,name=variables" json:"variables,omitempty"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *Environment) Reset()         { *m = Environment{} }
func (m *Environment) String() string { return proto.CompactTextString(m) }
func (*Environment) ProtoMessage()    {}

func (m *Environment) GetVariables() []*Environment_Variable {
	if m != nil {
		return m.Variables
	}
	return nil
}

type Environment_Variable struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Environment_Variable) Reset()         { *m = Environment_Variable{} }
func (m *Environment_Variable) String() string { return proto.CompactTextString(m) }
func (*Environment_Variable) ProtoMessage()    {}

func (m *Environment_Variable) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Environment_Variable) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// A generic (key, value) pair used in various places for parameters.
type Parameter struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Parameter) Reset()         { *m = Parameter{} }
func (m *Parameter) String() string { return proto.CompactTextString(m) }
func (*Parameter) ProtoMessage()    {}

func (m *Parameter) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Parameter) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// Collection of Parameter.
type Parameters struct {
	Parameter        []*Parameter `protobuf:"bytes,1,rep,name=parameter" json:"parameter,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *Parameters) Reset()         { *m = Parameters{} }
func (m *Parameters) String() string { return proto.CompactTextString(m) }
func (*Parameters) ProtoMessage()    {}

func (m *Parameters) GetParameter() []*Parameter {
	if m != nil {
		return m.Parameter
	}
	return nil
}

// *
// Credential used in various places for authentication and
// authorization.
//
// NOTE: A 'principal' is different from 'FrameworkInfo.user'. The
// former is used for authentication and authorization while the
// latter is used to determine the default user under which the
// framework's executors/tasks are run.
type Credential struct {
	Principal        *string `protobuf:"bytes,1,req,name=principal" json:"principal,omitempty"`
	Secret           []byte  `protobuf:"bytes,2,opt,name=secret" json:"secret,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Credential) Reset()         { *m = Credential{} }
func (m *Credential) String() string { return proto.CompactTextString(m) }
func (*Credential) ProtoMessage()    {}

func (m *Credential) GetPrincipal() string {
	if m != nil && m.Principal != nil {
		return *m.Principal
	}
	return ""
}

func (m *Credential) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

// *
// Credentials used for framework authentication, HTTP authentication
// (where the common 'username' and 'password' are captured as
// 'principal' and 'secret' respectively), etc.
type Credentials struct {
	Credentials      []*Credential `protobuf:"bytes,1,rep,name=credentials" json:"credentials,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Credentials) Reset()         { *m = Credentials{} }
func (m *Credentials) String() string { return proto.CompactTextString(m) }
func (*Credentials) ProtoMessage()    {}

func (m *Credentials) GetCredentials() []*Credential {
	if m != nil {
		return m.Credentials
	}
	return nil
}

// *
// ACLs used for authorization.
type ACL struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *ACL) Reset()         { *m = ACL{} }
func (m *ACL) String() string { return proto.CompactTextString(m) }
func (*ACL) ProtoMessage()    {}

// Entity is used to describe a subject(s) or an object(s) of an ACL.
// NOTE:
// To allow everyone access to an Entity set its type to 'ANY'.
// To deny access to an Entity set its type to 'NONE'.
type ACL_Entity struct {
	Type             *ACL_Entity_Type `protobuf:"varint,1,opt,name=type,enum=mesosproto.ACL_Entity_Type,def=0" json:"type,omitempty"`
	Values           []string         `protobuf:"bytes,2,rep,name=values" json:"values,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *ACL_Entity) Reset()         { *m = ACL_Entity{} }
func (m *ACL_Entity) String() string { return proto.CompactTextString(m) }
func (*ACL_Entity) ProtoMessage()    {}

const Default_ACL_Entity_Type ACL_Entity_Type = ACL_Entity_SOME

func (m *ACL_Entity) GetType() ACL_Entity_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_ACL_Entity_Type
}

func (m *ACL_Entity) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

// ACLs.
type ACL_RegisterFramework struct {
	// Subjects.
	Principals *ACL_Entity `protobuf:"bytes,1,req,name=principals" json:"principals,omitempty"`
	// Objects.
	Roles            *ACL_Entity `protobuf:"bytes,2,req,name=roles" json:"roles,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *ACL_RegisterFramework) Reset()         { *m = ACL_RegisterFramework{} }
func (m *ACL_RegisterFramework) String() string { return proto.CompactTextString(m) }
func (*ACL_RegisterFramework) ProtoMessage()    {}

func (m *ACL_RegisterFramework) GetPrincipals() *ACL_Entity {
	if m != nil {
		return m.Principals
	}
	return nil
}

func (m *ACL_RegisterFramework) GetRoles() *ACL_Entity {
	if m != nil {
		return m.Roles
	}
	return nil
}

type ACL_RunTask struct {
	// Subjects.
	Principals *ACL_Entity `protobuf:"bytes,1,req,name=principals" json:"principals,omitempty"`
	// Objects.
	Users            *ACL_Entity `protobuf:"bytes,2,req,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *ACL_RunTask) Reset()         { *m = ACL_RunTask{} }
func (m *ACL_RunTask) String() string { return proto.CompactTextString(m) }
func (*ACL_RunTask) ProtoMessage()    {}

func (m *ACL_RunTask) GetPrincipals() *ACL_Entity {
	if m != nil {
		return m.Principals
	}
	return nil
}

func (m *ACL_RunTask) GetUsers() *ACL_Entity {
	if m != nil {
		return m.Users
	}
	return nil
}

// Which principals are authorized to shutdown frameworks of other
// principals.
type ACL_ShutdownFramework struct {
	// Subjects.
	Principals *ACL_Entity `protobuf:"bytes,1,req,name=principals" json:"principals,omitempty"`
	// Objects.
	FrameworkPrincipals *ACL_Entity `protobuf:"bytes,2,req,name=framework_principals" json:"framework_principals,omitempty"`
	XXX_unrecognized    []byte      `json:"-"`
}

func (m *ACL_ShutdownFramework) Reset()         { *m = ACL_ShutdownFramework{} }
func (m *ACL_ShutdownFramework) String() string { return proto.CompactTextString(m) }
func (*ACL_ShutdownFramework) ProtoMessage()    {}

func (m *ACL_ShutdownFramework) GetPrincipals() *ACL_Entity {
	if m != nil {
		return m.Principals
	}
	return nil
}

func (m *ACL_ShutdownFramework) GetFrameworkPrincipals() *ACL_Entity {
	if m != nil {
		return m.FrameworkPrincipals
	}
	return nil
}

// *
// Collection of ACL.
//
// Each authorization request is evaluated against the ACLs in the order
// they are defined.
//
// For simplicity, the ACLs for a given action are not aggregated even
// when they have the same subjects or objects. The first ACL that
// matches the request determines whether that request should be
// permitted or not. An ACL matches iff both the subjects
// (e.g., clients, principals) and the objects (e.g., urls, users,
// roles) of the ACL match the request.
//
// If none of the ACLs match the request, the 'permissive' field
// determines whether the request should be permitted or not.
//
// TODO(vinod): Do aggregation of ACLs when possible.
//
type ACLs struct {
	Permissive         *bool                    `protobuf:"varint,1,opt,name=permissive,def=1" json:"permissive,omitempty"`
	RegisterFrameworks []*ACL_RegisterFramework `protobuf:"bytes,2,rep,name=register_frameworks" json:"register_frameworks,omitempty"`
	RunTasks           []*ACL_RunTask           `protobuf:"bytes,3,rep,name=run_tasks" json:"run_tasks,omitempty"`
	ShutdownFrameworks []*ACL_ShutdownFramework `protobuf:"bytes,4,rep,name=shutdown_frameworks" json:"shutdown_frameworks,omitempty"`
	XXX_unrecognized   []byte                   `json:"-"`
}

func (m *ACLs) Reset()         { *m = ACLs{} }
func (m *ACLs) String() string { return proto.CompactTextString(m) }
func (*ACLs) ProtoMessage()    {}

const Default_ACLs_Permissive bool = true

func (m *ACLs) GetPermissive() bool {
	if m != nil && m.Permissive != nil {
		return *m.Permissive
	}
	return Default_ACLs_Permissive
}

func (m *ACLs) GetRegisterFrameworks() []*ACL_RegisterFramework {
	if m != nil {
		return m.RegisterFrameworks
	}
	return nil
}

func (m *ACLs) GetRunTasks() []*ACL_RunTask {
	if m != nil {
		return m.RunTasks
	}
	return nil
}

func (m *ACLs) GetShutdownFrameworks() []*ACL_ShutdownFramework {
	if m != nil {
		return m.ShutdownFrameworks
	}
	return nil
}

// *
// Rate (queries per second, QPS) limit for messages from a framework to master.
// Strictly speaking they are the combined rate from all frameworks of the same
// principal.
type RateLimit struct {
	// Leaving QPS unset gives it unlimited rate (i.e., not throttled),
	// which also implies unlimited capacity.
	Qps *float64 `protobuf:"fixed64,1,opt,name=qps" json:"qps,omitempty"`
	// Principal of framework(s) to be throttled. Should match
	// FrameworkInfo.princpal and Credential.principal (if using authentication).
	Principal *string `protobuf:"bytes,2,req,name=principal" json:"principal,omitempty"`
	// Max number of outstanding messages from frameworks of this principal
	// allowed by master before the next message is dropped and an error is sent
	// back to the sender. Messages received before the capacity is reached are
	// still going to be processed after the error is sent.
	// If unspecified, this principal is assigned unlimited capacity.
	// NOTE: This value is ignored if 'qps' is not set.
	Capacity         *uint64 `protobuf:"varint,3,opt,name=capacity" json:"capacity,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RateLimit) Reset()         { *m = RateLimit{} }
func (m *RateLimit) String() string { return proto.CompactTextString(m) }
func (*RateLimit) ProtoMessage()    {}

func (m *RateLimit) GetQps() float64 {
	if m != nil && m.Qps != nil {
		return *m.Qps
	}
	return 0
}

func (m *RateLimit) GetPrincipal() string {
	if m != nil && m.Principal != nil {
		return *m.Principal
	}
	return ""
}

func (m *RateLimit) GetCapacity() uint64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

// *
// Collection of RateLimit.
// Frameworks without rate limits defined here are not throttled unless
// 'aggregate_default_qps' is specified.
type RateLimits struct {
	// Items should have unique principals.
	Limits []*RateLimit `protobuf:"bytes,1,rep,name=limits" json:"limits,omitempty"`
	// All the frameworks not specified in 'limits' get this default rate.
	// This rate is an aggregate rate for all of them, i.e., their combined
	// traffic is throttled together at this rate.
	AggregateDefaultQps *float64 `protobuf:"fixed64,2,opt,name=aggregate_default_qps" json:"aggregate_default_qps,omitempty"`
	// All the frameworks not specified in 'limits' get this default capacity.
	// This is an aggregate value similar to 'aggregate_default_qps'.
	AggregateDefaultCapacity *uint64 `protobuf:"varint,3,opt,name=aggregate_default_capacity" json:"aggregate_default_capacity,omitempty"`
	XXX_unrecognized         []byte  `json:"-"`
}

func (m *RateLimits) Reset()         { *m = RateLimits{} }
func (m *RateLimits) String() string { return proto.CompactTextString(m) }
func (*RateLimits) ProtoMessage()    {}

func (m *RateLimits) GetLimits() []*RateLimit {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *RateLimits) GetAggregateDefaultQps() float64 {
	if m != nil && m.AggregateDefaultQps != nil {
		return *m.AggregateDefaultQps
	}
	return 0
}

func (m *RateLimits) GetAggregateDefaultCapacity() uint64 {
	if m != nil && m.AggregateDefaultCapacity != nil {
		return *m.AggregateDefaultCapacity
	}
	return 0
}

// *
// Describes a volume mapping either from host to container or vice
// versa. Both paths can either refer to a directory or a file.
type Volume struct {
	// Absolute path pointing to a directory or file in the container.
	ContainerPath *string `protobuf:"bytes,1,req,name=container_path" json:"container_path,omitempty"`
	// Absolute path pointing to a directory or file on the host.
	HostPath         *string      `protobuf:"bytes,2,opt,name=host_path" json:"host_path,omitempty"`
	Mode             *Volume_Mode `protobuf:"varint,3,req,name=mode,enum=mesosproto.Volume_Mode" json:"mode,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *Volume) Reset()         { *m = Volume{} }
func (m *Volume) String() string { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()    {}

func (m *Volume) GetContainerPath() string {
	if m != nil && m.ContainerPath != nil {
		return *m.ContainerPath
	}
	return ""
}

func (m *Volume) GetHostPath() string {
	if m != nil && m.HostPath != nil {
		return *m.HostPath
	}
	return ""
}

func (m *Volume) GetMode() Volume_Mode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return Volume_RW
}

// *
// Describes a container configuration and allows extensible
// configurations for different container implementation.
type ContainerInfo struct {
	Type             *ContainerInfo_Type       `protobuf:"varint,1,req,name=type,enum=mesosproto.ContainerInfo_Type" json:"type,omitempty"`
	Volumes          []*Volume                 `protobuf:"bytes,2,rep,name=volumes" json:"volumes,omitempty"`
	Docker           *ContainerInfo_DockerInfo `protobuf:"bytes,3,opt,name=docker" json:"docker,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *ContainerInfo) Reset()         { *m = ContainerInfo{} }
func (m *ContainerInfo) String() string { return proto.CompactTextString(m) }
func (*ContainerInfo) ProtoMessage()    {}

func (m *ContainerInfo) GetType() ContainerInfo_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ContainerInfo_DOCKER
}

func (m *ContainerInfo) GetVolumes() []*Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *ContainerInfo) GetDocker() *ContainerInfo_DockerInfo {
	if m != nil {
		return m.Docker
	}
	return nil
}

type ContainerInfo_DockerInfo struct {
	// The docker image that is going to be passed to the registry.
	Image            *string                                 `protobuf:"bytes,1,req,name=image" json:"image,omitempty"`
	Network          *ContainerInfo_DockerInfo_Network       `protobuf:"varint,2,opt,name=network,enum=mesosproto.ContainerInfo_DockerInfo_Network,def=1" json:"network,omitempty"`
	PortMappings     []*ContainerInfo_DockerInfo_PortMapping `protobuf:"bytes,3,rep,name=port_mappings" json:"port_mappings,omitempty"`
	XXX_unrecognized []byte                                  `json:"-"`
}

func (m *ContainerInfo_DockerInfo) Reset()         { *m = ContainerInfo_DockerInfo{} }
func (m *ContainerInfo_DockerInfo) String() string { return proto.CompactTextString(m) }
func (*ContainerInfo_DockerInfo) ProtoMessage()    {}

const Default_ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo_Network = ContainerInfo_DockerInfo_HOST

func (m *ContainerInfo_DockerInfo) GetImage() string {
	if m != nil && m.Image != nil {
		return *m.Image
	}
	return ""
}

func (m *ContainerInfo_DockerInfo) GetNetwork() ContainerInfo_DockerInfo_Network {
	if m != nil && m.Network != nil {
		return *m.Network
	}
	return Default_ContainerInfo_DockerInfo_Network
}

func (m *ContainerInfo_DockerInfo) GetPortMappings() []*ContainerInfo_DockerInfo_PortMapping {
	if m != nil {
		return m.PortMappings
	}
	return nil
}

type ContainerInfo_DockerInfo_PortMapping struct {
	HostPort      *uint32 `protobuf:"varint,1,req,name=host_port" json:"host_port,omitempty"`
	ContainerPort *uint32 `protobuf:"varint,2,req,name=container_port" json:"container_port,omitempty"`
	// Protocol to expose as (ie: tcp, udp).
	Protocol         *string `protobuf:"bytes,3,opt,name=protocol" json:"protocol,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ContainerInfo_DockerInfo_PortMapping) Reset()         { *m = ContainerInfo_DockerInfo_PortMapping{} }
func (m *ContainerInfo_DockerInfo_PortMapping) String() string { return proto.CompactTextString(m) }
func (*ContainerInfo_DockerInfo_PortMapping) ProtoMessage()    {}

func (m *ContainerInfo_DockerInfo_PortMapping) GetHostPort() uint32 {
	if m != nil && m.HostPort != nil {
		return *m.HostPort
	}
	return 0
}

func (m *ContainerInfo_DockerInfo_PortMapping) GetContainerPort() uint32 {
	if m != nil && m.ContainerPort != nil {
		return *m.ContainerPort
	}
	return 0
}

func (m *ContainerInfo_DockerInfo_PortMapping) GetProtocol() string {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ""
}

func init() {
	proto.RegisterEnum("mesosproto.Status", Status_name, Status_value)
	proto.RegisterEnum("mesosproto.TaskState", TaskState_name, TaskState_value)
	proto.RegisterEnum("mesosproto.Value_Type", Value_Type_name, Value_Type_value)
	proto.RegisterEnum("mesosproto.ACL_Entity_Type", ACL_Entity_Type_name, ACL_Entity_Type_value)
	proto.RegisterEnum("mesosproto.Volume_Mode", Volume_Mode_name, Volume_Mode_value)
	proto.RegisterEnum("mesosproto.ContainerInfo_Type", ContainerInfo_Type_name, ContainerInfo_Type_value)
	proto.RegisterEnum("mesosproto.ContainerInfo_DockerInfo_Network", ContainerInfo_DockerInfo_Network_name, ContainerInfo_DockerInfo_Network_value)
}
